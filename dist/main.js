(()=>{"use strict";const t=class{constructor(t){this.value=t,this.left=null,this.right=null}},e=class{constructor(t){this.value=t,this.next=null}},l=class{constructor(){this.head=null,this.tail=null}enqueue(t){const l=new e(t);this.head?(this.tail.next=l,this.tail=l):(this.head=l,this.tail=l)}dequeue(){if(!this.head)return null;let t=this.head.value;return this.head=this.head.next,this.head||(this.tail=null),t}},r=class{constructor(){this.top=null,this.bottom=null}push(t){const l=new e(t);this.top?(l.next=this.top,this.top=l):(this.bottom=l,this.top=l)}pop(){if(!this.top)return null;const t=this.top;return this.top=this.top.next,this.top||(this.bottom=null),t.value}},i=(t,e="",l=!0)=>{null!==t&&(null!==t.right&&i(t.right,`${e}${l?"│   ":"    "}`,!1),console.log(`${e}${l?"└── ":"┌── "}${t.value}`),null!==t.left&&i(t.left,`${e}${l?"    ":"│   "}`,!0))};let o=[];const s=t=>{o.push(t.value)};let h=[];for(let t=0;t<10;t++)h.push(Math.floor(100*Math.random())+1);let n=new class{constructor(t){t=(t=[...new Set(t)]).sort(((t,e)=>t-e)),this.root=this.buildTree(t)}buildTree(e){if(0===e.length)return null;let l=Math.floor(e.length/2);const r=new t(e[l]);return r.left=this.buildTree(e.slice(0,l)),r.right=this.buildTree(e.slice(l+1)),r}insert(e){if(!Number.isInteger(e))throw new Error("value is not integer");const l=new t(e);let r=this.root,i=null;for(;null!==r;)if(i=r,e>r.value)r=r.right;else{if(!(e<r.value))throw new Error("value already exist in the BST");r=r.left}e>i.value?i.right=l:i.left=l}deleteItem(t){if(!Number.isInteger(t))throw new Error("value is not integer");let e=this.root,l=null,r=!0;for(;null!==e&&t!==e.value;)l=e,r=t<e.value,e=r?e.left:e.right;if(!e)throw new Error("value do not exist in the BST");if(e.right||e.left)if(e.right)if(e.left){let t=this.findMin(e.right).value;this.deleteItem(t),l?r?l.left.value=t:l.right.value=t:this.root.value=t}else l?r?l.left=e.right:l.right=e.right:this.root=e.right;else l?r?l.left=e.left:l.right=e.left:this.root=e.left;else l?r?l.left=null:l.right=null:this.root=null}findMin(t=this.root){let e=t;for(;e.left;)e=e.left;return e}find(t){if(!Number.isInteger(t))throw new Error("value is not integer");let e=this.root,l=!0;for(;null!==e;){if(t===e.value)return e;l=t<e.value,e=l?e.left:e.right}throw new Error("value do not exist in the BST")}levelOrder(t){const e=new l;for(e.enqueue(this.root);e.head;){let l=e.dequeue();t(l),l.left&&e.enqueue(l.left),l.right&&e.enqueue(l.right)}}inOrder(t){const e=new r;let l=this.root;for(;l||e.top;){for(;l;)e.push(l),l=l.left;l=e.pop(),t(l),l=l.right}}preOrder(t){const e=new r;let l=this.root;for(;l;)l&&(t(l),l.right&&e.push(l.right),l.left&&e.push(l.left)),l=e.pop()}postOrder(t){const e=new r,l=new r;for(e.push(this.root);e.top;){let t=e.pop();l.push(t),t.left&&e.push(t.left),t.right&&e.push(t.right)}for(;l.top;)t(l.pop())}height(t=this.root){if(null===t)return-1;let e=this.height(t.left),l=this.height(t.right);return Math.max(e,l)+1}depth(t){return this.height()-this.height(t)}isBalanced(t=this.root){return null===t||!(Math.abs(this.height(t.left)-this.height(t.right))>1)&&(!t.left&&!t.right||this.isBalanced(t.left)&&this.isBalanced(t.right))}rebalance(){let t=[];this.inOrder((e=>t.push(e.value))),this.root=this.buildTree(t)}}(h);i(n.root),console.log(n.isBalanced()),o=[],n.levelOrder(s),console.log(o),o=[],n.inOrder(s),console.log(o),o=[],n.preOrder(s),console.log(o),o=[],n.postOrder(s),console.log(o),n.insert(101),n.insert(123),n.insert(169),i(n.root),console.log(n.isBalanced()),n.rebalance(),i(n.root),console.log(n.isBalanced()),o=[],n.levelOrder(s),console.log(o),o=[],n.inOrder(s),console.log(o),o=[],n.preOrder(s),console.log(o),o=[],n.postOrder(s),console.log(o)})();